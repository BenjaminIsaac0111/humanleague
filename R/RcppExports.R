# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Generate a population in n dimensions given n marginals.
#'
#' Using Quasirandom Integer Without-replacement Sampling (QIWS), this function
#' generates an n-dimensional population table where elements sum to the input marginals, and supplemental data.
#' @param marginals a List of n integer vectors containing marginal data (2 <= n <= 12). The sum of elements in each vector must be identical
#' @return an object containing: the population matrix, the occupancy probability matrix, a convergence flag, the chi-squared statistic, p-value, and error value (nonzero if not converged)
#' @examples
#' synthPop(list(c(1,2,3,4), c(3,4,3)))
#' @export
synthPop <- function(marginals) {
    .Call('_humanleague_synthPop', PACKAGE = 'humanleague', marginals)
}

#' IPF
#'
#' C++ IPF implementation
#' @param seed an n-dimensional array of seed values
#' @param marginals a List of n integer vectors containing marginal data. The sum of elements in each vector must be identical
#' @return an object containing: ...
#' @export
ipf <- function(seed, marginals) {
    .Call('_humanleague_ipf', PACKAGE = 'humanleague', seed, marginals)
}

#' QSIPF
#'
#' C++ QSIPF implementation
#' @param seed an n-dimensional array of seed values
#' @param marginals a List of n integer vectors containing marginal data. The sum of elements in each vector must be identical
#' @return an object containing: ...
#' @export
qsipf <- function(seed, marginals) {
    .Call('_humanleague_qsipf', PACKAGE = 'humanleague', seed, marginals)
}

#' Generate integer frequencies from discrete probabilities and an overall population.
#'
#' This function will generate the closest integer vector to the probabilities scaled to the population.
#' @param pIn a numeric vector of state occupation probabilities. Must sum to unity (to within double precision epsilon)
#' @param pop the total population
#' @return an integer vector of frequencies that sums to pop.
#' @examples
#' prob2IntFreq(c(0.1,0.2,0.3,0.4), 11)
#' @export
prob2IntFreq <- function(pIn, pop) {
    .Call('_humanleague_prob2IntFreq', PACKAGE = 'humanleague', pIn, pop)
}

#' Generate Sobol' quasirandom sequence
#'
#' @param dim dimensions
#' @param n number of variates to sample
#' @param skip number of variates to skip (actual number skipped will be largest power of 2 less than k)
#' @return a n-by-d matrix of uniform probabilities in (0,1).
#' @examples
#' sobolSequence(2, 1000, 1000) # will skip 512 numbers!
#' @export
sobolSequence <- function(dim, n, skip = 0L) {
    .Call('_humanleague_sobolSequence', PACKAGE = 'humanleague', dim, n, skip)
}

#' Generate correlated 2D Sobol' quasirandom sequence
#'
#' @param rho correlation
#' @param n number of variates to sample
#' @param skip number of variates to skip (actual number skipped will be largest power of 2 less than k)
#' @return a n-by-2 matrix of uniform correlated probabilities in (0,1).
#' @examples
#' correlatedSobol2Sequence(0.2, 1000)
#' @export
correlatedSobol2Sequence <- function(rho, n, skip = 0L) {
    .Call('_humanleague_correlatedSobol2Sequence', PACKAGE = 'humanleague', rho, n, skip)
}

#' Entry point to enable running unit tests within R (e.g. in testthat)
#'
#' @return a List containing, number of tests run, number of failures, and any error messages.
#' @examples
#' unitTest()
#' @export
unitTest <- function() {
    .Call('_humanleague_unitTest', PACKAGE = 'humanleague')
}

