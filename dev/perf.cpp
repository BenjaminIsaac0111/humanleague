
#include "src/IPF.h"
#include "src/QIS.h"
#include "src/QSIPF.h"
#include "src/Sobol.h"

#include "src/NDArray.h"
#include "src/Index.h"
#include "src/NDArrayUtils.h"

#include <map>
#include <vector>
#include <iostream>

// TODO integer marginals
size_t n = 1000;

void do2dIPF()
{
  // std::vector<std::vector<double>> m = {std::vector<double>{144., 150., 3., 2., 153., 345., 13., 11., 226., 304., 24., 18., 250., 336., 14., 21., 190., 176., 15., 14., 27., 10., 2., 3., 93., 135., 2., 6., 30., 465., 11., 28., 43., 463., 17., 76., 39., 458., 15., 88., 55., 316., 22., 50., 15., 25., 11., 17}, 
  // std::vector<double>{18., 1., 1., 3., 6., 5., 1., 2., 1., 8., 2., 3., 4., 2., 4., 2., 2., 2., 4., 2., 4., 2., 2., 8., 10., 6., 2., 1., 2., 2., 2., 1., 1., 1., 5., 1., 2., 1., 1., 1., 3., 2., 1., 3., 3., 1., 1., 4., 4., 1., 1., 5., 4., 10., 1., 6., 2., 67., 1., 10., 7., 9., 4., 21., 19., 9., 131., 17., 9., 8., 14., 17., 13., 11., 3., 6., 2., 2., 3., 1., 12., 1., 1., 1., 2., 1., 1., 1., 2., 21., 1., 26., 97., 10., 47., 6., 2., 3., 2., 7., 2., 17., 2., 6., 3., 1., 1., 2., 18., 9., 59., 5., 399., 71., 100., 157., 74., 199., 154., 98., 22., 7., 13., 39., 19., 6., 43., 41., 24., 14., 30., 30., 105., 604., 15., 69., 33., 1., 122., 17., 20., 9., 77., 4., 9., 4., 56., 1., 32., 10., 9., 79., 4., 2., 30., 116., 3., 6., 14., 18., 2., 2., 9., 4., 11., 12., 5., 5., 2., 1., 1., 3., 9., 2., 7., 3., 1., 4., 1., 3., 2., 1., 7., 1., 7., 4., 17., 3., 5., 2., 6., 11., 2., 2., 3., 13., 3., 5., 1., 3., 2., 4., 2., 1., 16., 4., 1., 3., 7., 4., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 3., 1., 2., 2., 1., 1., 2., 1., 1., 1., 1., 2., 1., 1., 1., 1., 2., 6., 1., 1., 1., 2., 1., 1., 1., 2., 1., 1., 1., 1., 1., 1., 2., 1., 1., 1., 2., 1., 2., 1., 1., 1., 9., 1., 1., 2., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 2., 1., 1., 1., 1., 330., 28., 281., 12}};

  std::vector<NDArray<double>> m;
  std::vector<double> m0{144., 150., 3., 2., 153., 345., 13., 11., 226., 304., 24., 18., 250., 336., 14., 21., 190., 176., 15., 14., 27., 10., 2., 3., 93., 135., 2., 6., 30., 465., 11., 28., 43., 463., 17., 76., 39., 458., 15., 88., 55., 316., 22., 50., 15., 25., 11., 17}; 
  std::vector<double> m1{18., 1., 1., 3., 6., 5., 1., 2., 1., 8., 2., 3., 4., 2., 4., 2., 2., 2., 4., 2., 4., 2., 2., 8., 10., 6., 2., 1., 2., 2., 2., 1., 1., 1., 5., 1., 2., 1., 1., 1., 3., 2., 1., 3., 3., 1., 1., 4., 4., 1., 1., 5., 4., 10., 1., 6., 2., 67., 1., 10., 7., 9., 4., 21., 19., 9., 131., 17., 9., 8., 14., 17., 13., 11., 3., 6., 2., 2., 3., 1., 12., 1., 1., 1., 2., 1., 1., 1., 2., 21., 1., 26., 97., 10., 47., 6., 2., 3., 2., 7., 2., 17., 2., 6., 3., 1., 1., 2., 18., 9., 59., 5., 399., 71., 100., 157., 74., 199., 154., 98., 22., 7., 13., 39., 19., 6., 43., 41., 24., 14., 30., 30., 105., 604., 15., 69., 33., 1., 122., 17., 20., 9., 77., 4., 9., 4., 56., 1., 32., 10., 9., 79., 4., 2., 30., 116., 3., 6., 14., 18., 2., 2., 9., 4., 11., 12., 5., 5., 2., 1., 1., 3., 9., 2., 7., 3., 1., 4., 1., 3., 2., 1., 7., 1., 7., 4., 17., 3., 5., 2., 6., 11., 2., 2., 3., 13., 3., 5., 1., 3., 2., 4., 2., 1., 16., 4., 1., 3., 7., 4., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 3., 1., 2., 2., 1., 1., 2., 1., 1., 1., 1., 2., 1., 1., 1., 1., 2., 6., 1., 1., 1., 2., 1., 1., 1., 2., 1., 1., 1., 1., 1., 1., 2., 1., 1., 1., 2., 1., 2., 1., 1., 1., 9., 1., 1., 2., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 2., 1., 1., 1., 1., 330., 28., 281., 12};
  m.push_back(NDArray<double>({(int64_t)m0.size()}, m0.data()));
  m.push_back(NDArray<double>({(int64_t)m1.size()}, m1.data()));
  
  std::vector<int64_t> size{ (int64_t)m0.size(), (int64_t)m1.size() };                                        

  NDArray<double> s(size);
  s.assign(1.0);
  //Index index(s.sizes());
  //s[index] = 0.5;
  IPF<double>::index_list_t index{std::vector<int64_t>{0},std::vector<int64_t>{1}};
  for (size_t i = 0; i < n; ++i)
  {
    IPF<double> ipf(index, m);
    ipf.solve(s);
  }
}

void do2dQIS()
{
  std::vector<NDArray<int64_t>> m;
  std::vector<int64_t> m0{144, 150, 3, 2, 153, 345, 13, 11, 226, 304, 24, 18, 250, 336, 14, 21, 190, 176, 15, 14, 27, 10, 2, 3, 93, 135, 2, 6, 30, 465, 11, 28, 43, 463, 17, 76, 39, 458, 15, 88, 55, 316, 22, 50, 15, 25, 11, 17}; 
  std::vector<int64_t> m1{18, 1, 1, 3, 6, 5, 1, 2, 1, 8, 2, 3, 4, 2, 4, 2, 2, 2, 4, 2, 4, 2, 2, 8, 10, 6, 2, 1, 2, 2, 2, 1, 1, 1, 5, 1, 2, 1, 1, 1, 3, 2, 1, 3, 3, 1, 1, 4, 4, 1, 1, 5, 4, 10, 1, 6, 2, 67, 1, 10, 7, 9, 4, 21, 19, 9, 131, 17, 9, 8, 14, 17, 13, 11, 3, 6, 2, 2, 3, 1, 12, 1, 1, 1, 2, 1, 1, 1, 2, 21, 1, 26, 97, 10, 47, 6, 2, 3, 2, 7, 2, 17, 2, 6, 3, 1, 1, 2, 18, 9, 59, 5, 399, 71, 100, 157, 74, 199, 154, 98, 22, 7, 13, 39, 19, 6, 43, 41, 24, 14, 30, 30, 105, 604, 15, 69, 33, 1, 122, 17, 20, 9, 77, 4, 9, 4, 56, 1, 32, 10, 9, 79, 4, 2, 30, 116, 3, 6, 14, 18, 2, 2, 9, 4, 11, 12, 5, 5, 2, 1, 1, 3, 9, 2, 7, 3, 1, 4, 1, 3, 2, 1, 7, 1, 7, 4, 17, 3, 5, 2, 6, 11, 2, 2, 3, 13, 3, 5, 1, 3, 2, 4, 2, 1, 16, 4, 1, 3, 7, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 2, 2, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 6, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 2, 1, 1, 1, 9, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 330, 28, 281, 12};  
  m.push_back(NDArray<int64_t>({(int64_t)m0.size()}, m0.data()));
  m.push_back(NDArray<int64_t>({(int64_t)m1.size()}, m1.data()));
  
  std::vector<std::vector<int64_t>> index;
  index.push_back(std::vector<int64_t>(1,0));
  index.push_back(std::vector<int64_t>(1,1));

  for (size_t i = 0; i < n; ++i)
  {
    QIS qis(index, m);
    qis.solve();
  }
}

void do3dIPF()
{
  std::vector<std::vector<double>> m = {std::vector<double>{52, 48}, 
                                        std::vector<double>{10, 77, 13},
                                        std::vector<double>{20, 27, 30, 23}};
  
  std::vector<int64_t> size{ (int64_t)m[0].size(), (int64_t)m[1].size(), (int64_t)m[2].size() };                                        

  NDArray<double> s(size);
  s.assign(1.0);
  //Index index(s.sizes());
  //s[index] = 0.5;

  deprecated::IPF ipf(s, m);

  auto e = ipf.errors();
  print(e[0]);
  print(e[1]);
  print(e[2]);
  std::cout << ipf.conv() << ":" << ipf.iters() << std::endl;
  print(ipf.result().rawData(), ipf.result().storageSize(), m[1].size());
  print(reduce(ipf.result(), 0));
  print(reduce(ipf.result(), 1));
  print(reduce(ipf.result(), 2));
}


int main()
{
  try
  {
    //do2dIPF();
    do2dQIS();
    //do3dIPF();
  }
  catch(const std::exception& e)
  {
    std::cout << e.what() << std::endl;
  }
  catch(...)
  {
    std::cout << "unknown exception" << std::endl;
  }  
}