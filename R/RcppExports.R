# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Generate a population in n dimensions given n marginals.
#'
#' Using Quasirandom Integer Without-replacement Sampling (QIWS), this function
#' generates an n-dimensional population table where elements sum to the input marginals, and supplemental data.
#' @param marginals a List of n integer vectors containing marginal data (2 <= n <= 12). The sum of elements in each vector must be identical
#' @return an object containing: the population matrix, the occupancy probability matrix, a convergence flag, the chi-squared statistic, p-value, and error value (nonzero if not converged)
#' @examples
#' synthPop(list(c(1,2,3,4), c(3,4,3)))
#' @export
synthPop <- function(marginals) {
    .Call('humanleague_synthPop', PACKAGE = 'humanleague', marginals)
}

#' Generate a constrained population in 2 dimensions given 2 marginals and a constraint matrix.
#'
#' Using Quasirandom Integer Without-replacement Sampling (QIWS), this function
#' generates a 2-dimensional population table where elements sum to the input marginals.
#' It then uses an iterative algorithm to reassign the population to only the permitted states.
#' @param marginals a List of 2 integer vectors containing marginal data. The sum of elements in each vector must be identical
#' @param permittedStates a matrix of booleans containing allowed states. The matrix dimensions must be the length of each marginal
#' @return an object containing: the population matrix, the occupancy probability matrix, a convergence flag, the chi-squared statistic, p-value, and error value (nonzero if not converged)
#' @examples
#' r = c(0, 3, 17, 124, 167, 79, 46, 22)
#' # rooms (1,2,3...9+)
#' b = c(0, 15, 165, 238, 33, 7) # bedrooms {0, 1,2...5+}
#' p = matrix(rep(TRUE,length(r)*length(b)), nrow=length(r)) # all states permitted
#' # now disallow bedrooms>rooms
#'   for (i in 1:length(r)) {
#'     for (j in 1:length(b)) {
#'       if (j > i + 1)
#'         p[i,j] = FALSE;
#'     }
#'   }
#' res = humanleague::synthPopC(list(r,b),p)
#' @export
synthPopC <- function(marginals, permittedStates) {
    .Call('humanleague_synthPopC', PACKAGE = 'humanleague', marginals, permittedStates)
}

#' Generate a correlated population in 2 dimensions given 2 marginals and a flat correlation.
#'
#' Using Quasirandom Integer Without-replacement Sampling (QIWS), this function
#' generates a 2-dimensional population table where elements sum to the input marginals.
#' @param marginals a List of 2 integer vectors containing marginal data. The sum of elements in each vector must be identical
#' @param rho correlation
#' @return an object containing: the population matrix, the occupancy probability matrix, a convergence flag, the chi-squared statistic, p-value, and error value (nonzero if not converged)
#' @examples
#' res = humanleague::synthPopR(list(c(10,10,10,10,10),c(10,10,10,10,10)),0.5)
#' @export
synthPopR <- function(marginals, rho) {
    .Call('humanleague_synthPopR', PACKAGE = 'humanleague', marginals, rho)
}

#' Constrained a pregenerated population in 2 dimensions given a constraint matrix.
#'
#' Using an iterative algorithm, this function
#' adjusts a 2-dimensional population table, reassigning populations in disallowed states to allowed ones, preserving the two marginal distributions
#' states where elements sum to the input marginals.
#' Users need to ensure that the supplied constraint matrix permits a valid population to be computed - this is not always obvious from the input data.
#' @param population an integer matrix containing the population.
#' @param permittedStates a matrix of booleans containing allowed states. The matrix dimensions must be the length of each marginal
#' @return an object containing: the adjusted population matrix and a convergence flag.
#' @examples
#' r = c(0, 3, 17, 124, 167, 79, 46, 22)
#' # rooms (1,2,3...9+)
#' b = c(0, 15, 165, 238, 33, 7) # bedrooms {0, 1,2...5+}
#' p = matrix(rep(TRUE,length(r)*length(b)), nrow=length(r)) # all states permitted
#' # now disallow bedrooms>rooms
#' for (i in 1:length(r)) {
#'   for (j in 1:length(b)) {
#'     if (j > i + 1)
#'       p[i,j] = FALSE;
#'   }
#' }
#' res = humanleague::synthPop(list(r,b)) # unconstrained synthesis
#' res = humanleague::constrain(res$x.hat, p)
#' @export
constrain <- function(population, permittedStates) {
    .Call('humanleague_constrain', PACKAGE = 'humanleague', population, permittedStates)
}

#' Generate integer frequencies from discrete probabilities and an overall population.
#'
#' This function will generate the closest integer vector to the probabilities scaled to the population.
#' @param pIn a numeric vector of state occupation probabilities. Must sum to unity (to within double precision epsilon)
#' @param pop the total population
#' @return an integer vector of frequencies that sums to pop.
#' @examples
#' prob2IntFreq(c(0.1,0.2,0.3,0.4), 11)
#' @export
prob2IntFreq <- function(pIn, pop) {
    .Call('humanleague_prob2IntFreq', PACKAGE = 'humanleague', pIn, pop)
}

#' Generate Sobol' quasirandom sequence
#'
#' @param dim dimensions
#' @param n number of variates to sample
#' @param skip number of variates to skip (actual number skipped will be largest power of 2 less than k)
#' @return a n-by-d matrix of uniform probabilities in (0,1).
#' @examples
#' sobolSequence(2, 1000, 1000) # will skip 512 numbers!
#' @export
sobolSequence <- function(dim, n, skip = 0L) {
    .Call('humanleague_sobolSequence', PACKAGE = 'humanleague', dim, n, skip)
}

#' Generate correlated 2D Sobol' quasirandom sequence
#'
#' @param rho correlation
#' @param n number of variates to sample
#' @param skip number of variates to skip (actual number skipped will be largest power of 2 less than k)
#' @return a n-by-2 matrix of uniform correlated probabilities in (0,1).
#' @examples
#' correlatedSobol2Sequence(0.2, 1000)
#' @export
correlatedSobol2Sequence <- function(rho, n, skip = 0L) {
    .Call('humanleague_correlatedSobol2Sequence', PACKAGE = 'humanleague', rho, n, skip)
}

#' Entry point to enable running unit tests within R (e.g. in testthat)
#'
#' @param categories a StringVector of characteristic names
#' @return a data frame.
#' @examples
#'
#' @export
generateTable <- function(categories, population) {
    .Call('humanleague_generateTable', PACKAGE = 'humanleague', categories, population)
}

#' Entry point to enable running unit tests within R (e.g. in testthat)
#'
#' @return a List containing, number of tests run, number of failures, and any error messages.
#' @examples
#' unitTest()
#' @export
unitTest <- function() {
    .Call('humanleague_unitTest', PACKAGE = 'humanleague')
}

